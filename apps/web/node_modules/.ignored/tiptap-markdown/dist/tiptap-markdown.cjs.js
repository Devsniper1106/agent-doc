'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@tiptap/core');
var prosemirrorMarkdown = require('prosemirror-markdown');
var markdownit = require('markdown-it');
var model = require('@tiptap/pm/model');
var taskListPlugin = require('markdown-it-task-lists');
var state = require('@tiptap/pm/state');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var markdownit__default = /*#__PURE__*/_interopDefaultLegacy(markdownit);
var taskListPlugin__default = /*#__PURE__*/_interopDefaultLegacy(taskListPlugin);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var MarkdownTightLists = core.Extension.create({
  name: 'markdownTightLists',
  addOptions: function addOptions() {
    return {
      tight: true,
      tightClass: 'tight',
      listTypes: ['bulletList', 'orderedList']
    };
  },
  addGlobalAttributes: function addGlobalAttributes() {
    var _this = this;
    return [{
      types: this.options.listTypes,
      attributes: {
        tight: {
          "default": this.options.tight,
          parseHTML: function parseHTML(element) {
            return element.getAttribute('data-tight') === 'true' || !element.querySelector('p');
          },
          renderHTML: function renderHTML(attributes) {
            return {
              "class": attributes.tight ? _this.options.tightClass : null,
              'data-tight': attributes.tight ? 'true' : null
            };
          }
        }
      }
    }];
  },
  addCommands: function addCommands() {
    var _this2 = this;
    return {
      toggleTight: function toggleTight() {
        var tight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return function (_ref) {
          var editor = _ref.editor,
            commands = _ref.commands;
          function toggleTight(name) {
            if (!editor.isActive(name)) {
              return false;
            }
            var attrs = editor.getAttributes(name);
            return commands.updateAttributes(name, {
              tight: tight !== null && tight !== void 0 ? tight : !(attrs !== null && attrs !== void 0 && attrs.tight)
            });
          }
          return _this2.options.listTypes.some(function (name) {
            return toggleTight(name);
          });
        };
      }
    };
  }
});

function scanDelims(text, pos) {
  var state = new (markdownit__default['default']().inline.State)(text, null, null, []);
  return state.scanDelims(pos, true);
}
function shiftDelim(text, delim, start, offset) {
  var res = text.substring(0, start) + text.substring(start + delim.length);
  res = res.substring(0, start + offset) + delim + res.substring(start + offset);
  return res;
}
function trimStart(text, delim, from, to) {
  var pos = from,
    res = text;
  while (pos < to) {
    if (scanDelims(res, pos).can_open) {
      break;
    }
    res = shiftDelim(res, delim, pos, 1);
    pos++;
  }
  return {
    text: res,
    from: pos,
    to: to
  };
}
function trimEnd(text, delim, from, to) {
  var pos = to,
    res = text;
  while (pos > from) {
    if (scanDelims(res, pos).can_close) {
      break;
    }
    res = shiftDelim(res, delim, pos, -1);
    pos--;
  }
  return {
    text: res,
    from: from,
    to: pos
  };
}
function trimInline(text, delim, from, to) {
  var state = {
    text: text,
    from: from,
    to: to
  };
  state = trimStart(state.text, delim, state.from, state.to);
  state = trimEnd(state.text, delim, state.from, state.to);
  if (state.to - state.from < delim.length + 1) {
    state.text = state.text.substring(0, state.from) + state.text.substring(state.to + delim.length);
  }
  return state.text;
}

/**
 * Override default MarkdownSerializerState to:
 * - handle commonmark delimiters (https://spec.commonmark.org/0.29/#left-flanking-delimiter-run)
 */
var MarkdownSerializerState = /*#__PURE__*/function (_BaseMarkdownSerializ) {
  _inherits(MarkdownSerializerState, _BaseMarkdownSerializ);
  var _super = _createSuper(MarkdownSerializerState);
  function MarkdownSerializerState(nodes, marks, options) {
    var _this;
    _classCallCheck(this, MarkdownSerializerState);
    _this = _super.call(this, nodes, marks, options !== null && options !== void 0 ? options : {});
    _this.inlines = [];
    return _this;
  }
  _createClass(MarkdownSerializerState, [{
    key: "render",
    value: function render(node, parent, index) {
      _get(_getPrototypeOf(MarkdownSerializerState.prototype), "render", this).call(this, node, parent, index);
      var top = this.inlines[this.inlines.length - 1];
      if (top !== null && top !== void 0 && top.start && top !== null && top !== void 0 && top.end) {
        var _this$normalizeInline = this.normalizeInline(top),
          delimiter = _this$normalizeInline.delimiter,
          start = _this$normalizeInline.start,
          end = _this$normalizeInline.end;
        this.out = trimInline(this.out, delimiter, start, end);
        this.inlines.pop();
      }
    }
  }, {
    key: "markString",
    value: function markString(mark, open, parent, index) {
      var info = this.marks[mark.type.name];
      if (info.expelEnclosingWhitespace) {
        if (open) {
          this.inlines.push({
            start: this.out.length,
            delimiter: info.open
          });
        } else {
          var top = this.inlines.pop();
          this.inlines.push(_objectSpread2(_objectSpread2({}, top), {}, {
            end: this.out.length
          }));
        }
      }
      return _get(_getPrototypeOf(MarkdownSerializerState.prototype), "markString", this).call(this, mark, open, parent, index);
    }
  }, {
    key: "normalizeInline",
    value: function normalizeInline(inline) {
      var start = inline.start;
        inline.end;
      while (this.out.charAt(start).match(/\s/)) {
        start++;
      }
      return _objectSpread2(_objectSpread2({}, inline), {}, {
        start: start
      });
    }
  }]);
  return MarkdownSerializerState;
}(prosemirrorMarkdown.MarkdownSerializerState);

var HTMLMark = core.Mark.create({
  name: 'markdownHTMLMark',
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: {
          open: function open(state, mark) {
            var _getMarkTags$, _getMarkTags;
            if (!this.editor.storage.markdown.options.html) {
              console.warn("Tiptap Markdown: \"".concat(mark.type.name, "\" mark is only available in html mode"));
              return '';
            }
            return (_getMarkTags$ = (_getMarkTags = getMarkTags(mark)) === null || _getMarkTags === void 0 ? void 0 : _getMarkTags[0]) !== null && _getMarkTags$ !== void 0 ? _getMarkTags$ : '';
          },
          close: function close(state, mark) {
            var _getMarkTags$2, _getMarkTags2;
            if (!this.editor.storage.markdown.options.html) {
              return '';
            }
            return (_getMarkTags$2 = (_getMarkTags2 = getMarkTags(mark)) === null || _getMarkTags2 === void 0 ? void 0 : _getMarkTags2[1]) !== null && _getMarkTags$2 !== void 0 ? _getMarkTags$2 : '';
          }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function getMarkTags(mark) {
  var schema = mark.type.schema;
  var node = schema.text(' ', [mark]);
  var html = core.getHTMLFromFragment(model.Fragment.from(node), schema);
  var match = html.match(/^(<.*?>) (<\/.*?>)$/);
  return match ? [match[1], match[2]] : null;
}

function elementFromString(value) {
  // add a wrapper to preserve leading and trailing whitespace
  var wrappedValue = "<body>".concat(value, "</body>");
  return new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;
}
function escapeHTML(value) {
  return value === null || value === void 0 ? void 0 : value.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}
function extractElement(node) {
  var parent = node.parentElement;
  var prepend = parent.cloneNode();
  while (parent.firstChild && parent.firstChild !== node) {
    prepend.appendChild(parent.firstChild);
  }
  if (prepend.childNodes.length > 0) {
    parent.parentElement.insertBefore(prepend, parent);
  }
  parent.parentElement.insertBefore(node, parent);
  if (parent.childNodes.length === 0) {
    parent.remove();
  }
}
function unwrapElement(node) {
  var parent = node.parentNode;
  while (node.firstChild) {
    parent.insertBefore(node.firstChild, node);
  }
  parent.removeChild(node);
}

var HTMLNode = core.Node.create({
  name: 'markdownHTMLNode',
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: function serialize(state, node, parent) {
          if (this.editor.storage.markdown.options.html) {
            state.write(serializeHTML(node, parent));
          } else {
            console.warn("Tiptap Markdown: \"".concat(node.type.name, "\" node is only available in html mode"));
            state.write("[".concat(node.type.name, "]"));
          }
          if (node.isBlock) {
            state.closeBlock(node);
          }
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function serializeHTML(node, parent) {
  var schema = node.type.schema;
  var html = core.getHTMLFromFragment(model.Fragment.from(node), schema);
  if (node.isBlock && parent.type.name === schema.topNodeType.name) {
    return formatBlock(html);
  }
  return html;
}

/**
 * format html block as per the commonmark spec
 */
function formatBlock(html) {
  var dom = elementFromString(html);
  var element = dom.firstElementChild;
  element.innerHTML = element.innerHTML.trim() ? "\n".concat(element.innerHTML, "\n") : "\n";
  return element.outerHTML;
}

var Blockquote = core.Node.create({
  name: 'blockquote'
});
var Blockquote$1 = Blockquote.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.nodes.blockquote,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var BulletList = core.Node.create({
  name: 'bulletList'
});
var BulletList$1 = BulletList.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: function serialize(state, node) {
          var _this = this;
          return state.renderList(node, "  ", function () {
            return (_this.editor.storage.markdown.options.bulletListMarker || "-") + " ";
          });
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var CodeBlock = core.Node.create({
  name: 'codeBlock'
});
var CodeBlock$1 = CodeBlock.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: function serialize(state, node) {
          state.write("```" + (node.attrs.language || "") + "\n");
          state.text(node.textContent, false);
          state.ensureNewLine();
          state.write("```");
          state.closeBlock(node);
        },
        parse: {
          setup: function setup(markdownit) {
            var _this$options$languag;
            markdownit.set({
              langPrefix: (_this$options$languag = this.options.languageClassPrefix) !== null && _this$options$languag !== void 0 ? _this$options$languag : 'language-'
            });
          },
          updateDOM: function updateDOM(element) {
            element.innerHTML = element.innerHTML.replace(/\n<\/code><\/pre>/g, '</code></pre>');
          }
        }
      }
    };
  }
});

var HardBreak = core.Node.create({
  name: 'hardBreak'
});
var HardBreak$1 = HardBreak.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.nodes.hard_break,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var Heading = core.Node.create({
  name: 'heading'
});
var Heading$1 = Heading.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.nodes.heading,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var HorizontalRule = core.Node.create({
  name: 'horizontalRule'
});
var HorizontalRule$1 = HorizontalRule.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.nodes.horizontal_rule,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var Image = core.Node.create({
  name: 'image'
});
var Image$1 = Image.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.nodes.image,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var ListItem = core.Node.create({
  name: 'listItem'
});
var ListItem$1 = ListItem.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.nodes.list_item,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var OrderedList = core.Node.create({
  name: 'orderedList'
});
var OrderedList$1 = OrderedList.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.nodes.ordered_list,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var Paragraph = core.Node.create({
  name: 'paragraph'
});
var Paragraph$1 = Paragraph.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.nodes.paragraph,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

function childNodes(node) {
  var _node$content$content, _node$content;
  return (_node$content$content = node === null || node === void 0 ? void 0 : (_node$content = node.content) === null || _node$content === void 0 ? void 0 : _node$content.content) !== null && _node$content$content !== void 0 ? _node$content$content : [];
}

var Table = core.Node.create({
  name: 'table'
});
var Table$1 = Table.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: function serialize(state, node, parent) {
          if (!isMarkdownSerializable(node)) {
            HTMLNode.storage.markdown.serialize.call(this, state, node, parent);
            return;
          }
          node.forEach(function (row, p, i) {
            state.write('| ');
            row.forEach(function (col, p, j) {
              if (j) {
                state.write(' | ');
              }
              var cellContent = col.firstChild;
              if (cellContent.textContent.trim()) {
                state.renderInline(cellContent);
              }
            });
            state.write(' |');
            state.ensureNewLine();
            if (!i) {
              var delimiterRow = Array.from({
                length: row.childCount
              }).map(function () {
                return '---';
              }).join(' | ');
              state.write("| ".concat(delimiterRow, " |"));
              state.ensureNewLine();
            }
          });
          state.closeBlock(node);
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});
function hasSpan(node) {
  return node.attrs.colspan > 1 || node.attrs.rowspan > 1;
}
function isMarkdownSerializable(node) {
  var rows = childNodes(node);
  var firstRow = rows[0];
  var bodyRows = rows.slice(1);
  if (childNodes(firstRow).some(function (cell) {
    return cell.type.name !== 'tableHeader' || hasSpan(cell);
  })) {
    return false;
  }
  if (bodyRows.some(function (row) {
    return childNodes(row).some(function (cell) {
      return cell.type.name === 'tableHeader' || hasSpan(cell);
    });
  })) {
    return false;
  }
  return true;
}

var TaskItem = core.Node.create({
  name: 'taskItem'
});
var TaskItem$1 = TaskItem.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: function serialize(state, node) {
          var check = node.attrs.checked ? '[x]' : '[ ]';
          state.write("".concat(check, " "));
          state.renderContent(node);
        },
        parse: {
          updateDOM: function updateDOM(element) {
            _toConsumableArray(element.querySelectorAll('.task-list-item')).forEach(function (item) {
              var input = item.querySelector('input');
              item.setAttribute('data-type', 'taskItem');
              if (input) {
                item.setAttribute('data-checked', input.checked);
                input.remove();
              }
            });
          }
        }
      }
    };
  }
});

var TaskList = core.Node.create({
  name: 'taskList'
});
var TaskList$1 = TaskList.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: BulletList$1.storage.markdown.serialize,
        parse: {
          setup: function setup(markdownit) {
            markdownit.use(taskListPlugin__default['default']);
          },
          updateDOM: function updateDOM(element) {
            _toConsumableArray(element.querySelectorAll('.contains-task-list')).forEach(function (list) {
              list.setAttribute('data-type', 'taskList');
            });
          }
        }
      }
    };
  }
});

var Text = core.Node.create({
  name: 'text'
});
var Text$1 = Text.extend({
  /**
   * @return {{markdown: MarkdownNodeSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: function serialize(state, node) {
          state.text(escapeHTML(node.text));
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var Bold = core.Mark.create({
  name: 'bold'
});
var Bold$1 = Bold.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.marks.strong,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var Code = core.Mark.create({
  name: 'code'
});
var Code$1 = Code.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.marks.code,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var Italic = core.Mark.create({
  name: 'italic'
});
var Italic$1 = Italic.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.marks.em,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var Link = core.Mark.create({
  name: 'link'
});
var Link$1 = Link.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: prosemirrorMarkdown.defaultMarkdownSerializer.marks.link,
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var Strike = core.Mark.create({
  name: 'strike'
});
var Strike$1 = Strike.extend({
  /**
   * @return {{markdown: MarkdownMarkSpec}}
   */
  addStorage: function addStorage() {
    return {
      markdown: {
        serialize: {
          open: '~~',
          close: '~~',
          expelEnclosingWhitespace: true
        },
        parse: {
          // handled by markdown-it
        }
      }
    };
  }
});

var markdownExtensions = [Blockquote$1, BulletList$1, CodeBlock$1, HardBreak$1, Heading$1, HorizontalRule$1, HTMLNode, Image$1, ListItem$1, OrderedList$1, Paragraph$1, Table$1, TaskItem$1, TaskList$1, Text$1, Bold$1, Code$1, HTMLMark, Italic$1, Link$1, Strike$1];

function getMarkdownSpec(extension) {
  var _extension$storage, _markdownExtensions$f;
  var markdownSpec = (_extension$storage = extension.storage) === null || _extension$storage === void 0 ? void 0 : _extension$storage.markdown;
  var defaultMarkdownSpec = (_markdownExtensions$f = markdownExtensions.find(function (e) {
    return e.name === extension.name;
  })) === null || _markdownExtensions$f === void 0 ? void 0 : _markdownExtensions$f.storage.markdown;
  if (markdownSpec || defaultMarkdownSpec) {
    return _objectSpread2(_objectSpread2({}, defaultMarkdownSpec), markdownSpec);
  }
  return null;
}

var MarkdownSerializer = /*#__PURE__*/function () {
  /**
   * @type {import('@tiptap/core').Editor}
   */

  function MarkdownSerializer(editor) {
    _classCallCheck(this, MarkdownSerializer);
    _defineProperty(this, "editor", null);
    this.editor = editor;
  }
  _createClass(MarkdownSerializer, [{
    key: "serialize",
    value: function serialize(content) {
      var state = new MarkdownSerializerState(this.nodes, this.marks, {
        hardBreakNodeName: HardBreak$1.name
      });
      state.renderContent(content);
      return state.out;
    }
  }, {
    key: "nodes",
    get: function get() {
      var _this = this,
        _this$editor$extensio;
      return _objectSpread2(_objectSpread2({}, Object.fromEntries(Object.keys(this.editor.schema.nodes).map(function (name) {
        return [name, _this.serializeNode(HTMLNode)];
      }))), Object.fromEntries((_this$editor$extensio = this.editor.extensionManager.extensions.filter(function (extension) {
        return extension.type === 'node' && _this.serializeNode(extension);
      }).map(function (extension) {
        return [extension.name, _this.serializeNode(extension)];
      })) !== null && _this$editor$extensio !== void 0 ? _this$editor$extensio : []));
    }
  }, {
    key: "marks",
    get: function get() {
      var _this2 = this,
        _this$editor$extensio2;
      return _objectSpread2(_objectSpread2({}, Object.fromEntries(Object.keys(this.editor.schema.marks).map(function (name) {
        return [name, _this2.serializeMark(HTMLMark)];
      }))), Object.fromEntries((_this$editor$extensio2 = this.editor.extensionManager.extensions.filter(function (extension) {
        return extension.type === 'mark' && _this2.serializeMark(extension);
      }).map(function (extension) {
        return [extension.name, _this2.serializeMark(extension)];
      })) !== null && _this$editor$extensio2 !== void 0 ? _this$editor$extensio2 : []));
    }
  }, {
    key: "serializeNode",
    value: function serializeNode(node) {
      var _getMarkdownSpec, _getMarkdownSpec$seri;
      return (_getMarkdownSpec = getMarkdownSpec(node)) === null || _getMarkdownSpec === void 0 ? void 0 : (_getMarkdownSpec$seri = _getMarkdownSpec.serialize) === null || _getMarkdownSpec$seri === void 0 ? void 0 : _getMarkdownSpec$seri.bind({
        editor: this.editor,
        options: node.options
      });
    }
  }, {
    key: "serializeMark",
    value: function serializeMark(mark) {
      var _getMarkdownSpec2;
      var serialize = (_getMarkdownSpec2 = getMarkdownSpec(mark)) === null || _getMarkdownSpec2 === void 0 ? void 0 : _getMarkdownSpec2.serialize;
      return serialize ? _objectSpread2(_objectSpread2({}, serialize), {}, {
        open: typeof serialize.open === 'function' ? serialize.open.bind({
          editor: this.editor,
          options: mark.options
        }) : serialize.open,
        close: typeof serialize.close === 'function' ? serialize.close.bind({
          editor: this.editor,
          options: mark.options
        }) : serialize.close
      }) : null;
    }
  }]);
  return MarkdownSerializer;
}();

var MarkdownParser = /*#__PURE__*/function () {
  /**
   * @type {import('@tiptap/core').Editor}
   */

  function MarkdownParser(editor) {
    _classCallCheck(this, MarkdownParser);
    _defineProperty(this, "editor", null);
    this.editor = editor;
  }
  _createClass(MarkdownParser, [{
    key: "parse",
    value: function parse(content) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        inline = _ref.inline;
      var _this$editor$storage$ = this.editor.storage.markdown.options,
        html = _this$editor$storage$.html,
        linkify = _this$editor$storage$.linkify,
        breaks = _this$editor$storage$.breaks;
      if (typeof content === 'string') {
        var renderer = markdownit__default['default']({
          html: html,
          linkify: linkify,
          breaks: breaks
        });
        this.editor.extensionManager.extensions.forEach(function (extension) {
          var _getMarkdownSpec, _getMarkdownSpec$pars, _getMarkdownSpec$pars2;
          return (_getMarkdownSpec = getMarkdownSpec(extension)) === null || _getMarkdownSpec === void 0 ? void 0 : (_getMarkdownSpec$pars = _getMarkdownSpec.parse) === null || _getMarkdownSpec$pars === void 0 ? void 0 : (_getMarkdownSpec$pars2 = _getMarkdownSpec$pars.setup) === null || _getMarkdownSpec$pars2 === void 0 ? void 0 : _getMarkdownSpec$pars2.call({
            editor: _this.editor,
            options: extension.options
          }, renderer);
        });
        var renderedHTML = renderer.render(content);
        var element = elementFromString(renderedHTML);
        this.editor.extensionManager.extensions.forEach(function (extension) {
          var _getMarkdownSpec2, _getMarkdownSpec2$par, _getMarkdownSpec2$par2;
          return (_getMarkdownSpec2 = getMarkdownSpec(extension)) === null || _getMarkdownSpec2 === void 0 ? void 0 : (_getMarkdownSpec2$par = _getMarkdownSpec2.parse) === null || _getMarkdownSpec2$par === void 0 ? void 0 : (_getMarkdownSpec2$par2 = _getMarkdownSpec2$par.updateDOM) === null || _getMarkdownSpec2$par2 === void 0 ? void 0 : _getMarkdownSpec2$par2.call({
            editor: _this.editor,
            options: extension.options
          }, element);
        });
        this.normalizeDOM(element, {
          inline: inline,
          content: content
        });
        return element.innerHTML;
      }
      return content;
    }
  }, {
    key: "normalizeDOM",
    value: function normalizeDOM(node) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        inline = _ref2.inline,
        content = _ref2.content;
      this.normalizeBlocks(node);
      if (inline) {
        this.normalizeInline(node, content);
      }
      return node;
    }
  }, {
    key: "normalizeBlocks",
    value: function normalizeBlocks(node) {
      var blocks = Object.values(this.editor.schema.nodes).filter(function (node) {
        return node.isBlock;
      });
      var selector = blocks.map(function (block) {
        var _block$spec$parseDOM;
        return (_block$spec$parseDOM = block.spec.parseDOM) === null || _block$spec$parseDOM === void 0 ? void 0 : _block$spec$parseDOM.map(function (spec) {
          return spec.tag;
        });
      }).flat().filter(Boolean).join(',');
      if (!selector) {
        return;
      }
      _toConsumableArray(node.querySelectorAll(selector)).forEach(function (el) {
        if (el.parentElement.matches('p')) {
          extractElement(el);
        }
      });
    }
  }, {
    key: "normalizeInline",
    value: function normalizeInline(node, content) {
      var _node$firstElementChi;
      if ((_node$firstElementChi = node.firstElementChild) !== null && _node$firstElementChi !== void 0 && _node$firstElementChi.matches('p')) {
        var _content$match$, _content$match, _content$match$2, _content$match2;
        var firstParagraph = node.firstElementChild;
        var nextSibling = firstParagraph.nextSibling,
          nextElementSibling = firstParagraph.nextElementSibling;
        var startSpaces = (_content$match$ = (_content$match = content.match(/^\s+/)) === null || _content$match === void 0 ? void 0 : _content$match[0]) !== null && _content$match$ !== void 0 ? _content$match$ : '';
        var endSpaces = !nextElementSibling ? (_content$match$2 = (_content$match2 = content.match(/\s+$/)) === null || _content$match2 === void 0 ? void 0 : _content$match2[0]) !== null && _content$match$2 !== void 0 ? _content$match$2 : '' : '';
        if ((nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.nodeType) === Node.TEXT_NODE) {
          nextSibling.textContent = nextSibling.textContent.replace(/^\n/, '');
        }
        if (content.match(/^\n\n/)) {
          firstParagraph.innerHTML = "".concat(firstParagraph.innerHTML).concat(endSpaces);
          return;
        }
        unwrapElement(firstParagraph);
        node.innerHTML = "".concat(startSpaces).concat(node.innerHTML).concat(endSpaces);
      }
    }
  }]);
  return MarkdownParser;
}();

var MarkdownClipboard = core.Extension.create({
  name: 'markdownClipboard',
  addOptions: function addOptions() {
    return {
      transformPastedText: false,
      transformCopiedText: false
    };
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this = this;
    return [new state.Plugin({
      key: new state.PluginKey('markdownClipboard'),
      props: {
        clipboardTextParser: function clipboardTextParser(text, context, plainText) {
          if (plainText || !_this.options.transformPastedText) {
            return null; // pasting with shift key prevents formatting
          }

          var parsed = _this.editor.storage.markdown.parser.parse(text, {
            inline: true
          });
          return model.DOMParser.fromSchema(_this.editor.schema).parseSlice(elementFromString(parsed), {
            preserveWhitespace: true
          });
        },
        /**
         * @param {import('prosemirror-model').Slice} slice
         */
        clipboardTextSerializer: function clipboardTextSerializer(slice) {
          if (!_this.options.transformCopiedText) {
            return null;
          }
          return _this.editor.storage.markdown.serializer.serialize(slice.content);
        }
      }
    })];
  }
});

var Markdown = core.Extension.create({
  name: 'markdown',
  priority: 50,
  addOptions: function addOptions() {
    return {
      html: true,
      tightLists: true,
      tightListClass: 'tight',
      bulletListMarker: '-',
      linkify: false,
      breaks: false,
      transformPastedText: false,
      transformCopiedText: false
    };
  },
  addCommands: function addCommands() {
    var commands = core.extensions.Commands.config.addCommands();
    return {
      setContent: function setContent(content, emitUpdate, parseOptions) {
        return function (props) {
          return commands.setContent(props.editor.storage.markdown.parser.parse(content), emitUpdate, parseOptions)(props);
        };
      },
      insertContentAt: function insertContentAt(range, content, options) {
        return function (props) {
          return commands.insertContentAt(range, props.editor.storage.markdown.parser.parse(content, {
            inline: true
          }), options)(props);
        };
      }
    };
  },
  onBeforeCreate: function onBeforeCreate() {
    var _this = this;
    this.editor.storage.markdown = {
      options: _objectSpread2({}, this.options),
      parser: new MarkdownParser(this.editor),
      serializer: new MarkdownSerializer(this.editor),
      getMarkdown: function getMarkdown() {
        return _this.editor.storage.markdown.serializer.serialize(_this.editor.state.doc);
      }
    };
    this.editor.options.initialContent = this.editor.options.content;
    this.editor.options.content = this.editor.storage.markdown.parser.parse(this.editor.options.content);
  },
  onCreate: function onCreate() {
    this.editor.options.content = this.editor.options.initialContent;
    delete this.editor.options.initialContent;
  },
  addStorage: function addStorage() {
    return {
      /// storage will be defined in onBeforeCreate() to prevent initial object overriding
    };
  },
  addExtensions: function addExtensions() {
    return [MarkdownTightLists.configure({
      tight: this.options.tightLists,
      tightClass: this.options.tightListClass
    }), MarkdownClipboard.configure({
      transformPastedText: this.options.transformPastedText,
      transformCopiedText: this.options.transformCopiedText
    })];
  }
});

exports.Markdown = Markdown;
//# sourceMappingURL=tiptap-markdown.cjs.js.map

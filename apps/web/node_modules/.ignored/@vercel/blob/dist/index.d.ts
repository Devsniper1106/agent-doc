import { Readable } from 'node:stream';
import { IncomingMessage } from 'node:http';

declare class BlobError extends Error {
    constructor(message: string);
}
declare class BlobAccessError extends Error {
    constructor();
}
declare class BlobUnknownError extends Error {
    constructor();
}

interface GenerateClientTokenOptions extends BlobCommandOptions {
    pathname: string;
    onUploadCompleted?: {
        callbackUrl: string;
        metadata?: string | null;
    };
    maximumSizeInBytes?: number;
    allowedContentTypes?: string[];
    validUntil?: number;
}
declare function generateClientTokenFromReadWriteToken({ token, ...args }: GenerateClientTokenOptions): Promise<string>;
declare function verifyCallbackSignature({ token, signature, body, }: {
    token?: string;
    signature: string;
    body: string;
}): Promise<boolean>;
type DecodedClientTokenPayload = Omit<GenerateClientTokenOptions, 'token'> & {
    validUntil: number;
};
declare function getPayloadFromClientToken(clientToken: string): DecodedClientTokenPayload;
declare const EventTypes: {
    readonly generateClientToken: "blob.generate-client-token";
    readonly uploadCompleted: "blob.upload-completed";
};
interface GenerateClientTokenEvent {
    type: (typeof EventTypes)['generateClientToken'];
    payload: {
        pathname: string;
        callbackUrl: string;
    };
}
interface BlobUploadCompletedEvent {
    type: (typeof EventTypes)['uploadCompleted'];
    payload: {
        blob: BlobResult;
        metadata?: string;
    };
}
type HandleBlobUploadBody = GenerateClientTokenEvent | BlobUploadCompletedEvent;
type RequestType = IncomingMessage | Request;
interface HandleBlobUploadOptions {
    body: HandleBlobUploadBody;
    onBeforeGenerateToken: (pathname: string) => Promise<Pick<GenerateClientTokenOptions, 'allowedContentTypes' | 'maximumSizeInBytes' | 'validUntil'> & {
        metadata?: string;
    }>;
    onUploadCompleted: (body: BlobUploadCompletedEvent['payload']) => Promise<void>;
    token?: string;
    request: RequestType;
}
declare function handleBlobUpload({ token, request, body, onBeforeGenerateToken, onUploadCompleted, }: HandleBlobUploadOptions): Promise<{
    type: GenerateClientTokenEvent['type'];
    clientToken: string;
} | {
    type: BlobUploadCompletedEvent['type'];
    response: 'ok';
}>;

interface BlobResult {
    url: string;
    size: string;
    uploadedAt: Date;
    pathname: string;
    contentType: string;
    contentDisposition: string;
}
interface ListBlobResult {
    blobs: BlobResult[];
    cursor?: string;
    hasMore: boolean;
}
interface ListCommandOptions extends BlobCommandOptions {
    limit?: number;
    prefix?: string;
    cursor?: string;
}
interface BlobCommandOptions {
    token?: string;
}
interface PutCommandOptions extends BlobCommandOptions {
    access: 'public';
    contentType?: string;
    handleBlobUploadUrl?: string;
}
declare function put(pathname: string, body: string | Readable | Blob | ArrayBuffer | FormData | ReadableStream | File, options: PutCommandOptions): Promise<BlobResult>;
type BlobDelResult<T extends string | string[]> = T extends string ? BlobResult | null : (BlobResult | null)[];
declare function del<T extends string | string[]>(url: T, options?: BlobCommandOptions): Promise<BlobDelResult<T>>;
declare function head(url: string, options?: BlobCommandOptions): Promise<BlobResult | null>;
declare function list(options?: ListCommandOptions): Promise<ListBlobResult>;

export { BlobAccessError, BlobCommandOptions, BlobError, BlobResult, BlobUnknownError, BlobUploadCompletedEvent, GenerateClientTokenOptions, HandleBlobUploadBody, HandleBlobUploadOptions, ListBlobResult, ListCommandOptions, PutCommandOptions, del, generateClientTokenFromReadWriteToken, getPayloadFromClientToken, handleBlobUpload, head, list, put, verifyCallbackSignature };

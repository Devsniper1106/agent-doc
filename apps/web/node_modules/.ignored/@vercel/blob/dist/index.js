import{fetch as b}from"undici";function s(e){if(typeof window!="undefined"){if(!(e!=null&&e.token))throw new l('"token" is required');if(!e.token.startsWith("vercel_blob_client"))throw new l("client upload only supports client tokens")}if(e!=null&&e.token)return e.token;if(!process.env.BLOB_READ_WRITE_TOKEN)throw new Error("BLOB_READ_WRITE_TOKEN environment variable is not set. Please set it to your write token.");return process.env.BLOB_READ_WRITE_TOKEN}var l=class extends Error{constructor(n){super(`Vercel Blob: ${n}`)}},c=class extends Error{constructor(){super("Vercel Blob: Access denied, please provide a valid token for this resource")}},p=class extends Error{constructor(){super("Vercel Blob: Unknown error, please contact support@vercel.com")}};import*as m from"crypto";async function w({token:e,...n}){var d;if(typeof window!="undefined")throw new Error('"generateClientTokenFromReadWriteToken" must be called from a server environment');let t=new Date;t.setSeconds(t.getSeconds()+30);let r=s({token:e}),[,,,o=null]=r.split("_");if(!o)throw new Error(e?'Invalid "token" parameter':"Invalid BLOB_READ_WRITE_TOKEN");let a=Buffer.from(JSON.stringify({...n,validUntil:(d=n.validUntil)!=null?d:t.getTime()})).toString("base64"),i=await R(a,r);if(!i)throw new Error("Unable to sign client token");return`vercel_blob_client_${o}_${Buffer.from(`${i}.${a}`).toString("base64")}`}async function T(e){return globalThis.crypto.subtle.importKey("raw",new TextEncoder().encode(s({token:e})),{name:"HMAC",hash:"SHA-256"},!1,["sign","verify"])}async function R(e,n){if(!globalThis.crypto)return m.createHmac("sha256",n).update(e).digest("hex");let t=await globalThis.crypto.subtle.sign("HMAC",await T(n),new TextEncoder().encode(e));return Buffer.from(new Uint8Array(t)).toString("hex")}async function k({token:e,signature:n,body:t}){let r=s({token:e});if(!globalThis.crypto){let a=m.createHmac("sha256",r).update(t).digest("hex"),i=Buffer.from(a),d=Buffer.from(n);return i.length===d.length&&m.timingSafeEqual(i,d)}return await globalThis.crypto.subtle.verify("HMAC",await T(e),v(n),new TextEncoder().encode(t))}function v(e){if(e.length%2!==0)throw new RangeError("Expected string to be an even number of characters");let n=new Uint8Array(e.length/2);for(let t=0;t<e.length;t+=2)n[t/2]=parseInt(e.substring(t,t+2),16);return Buffer.from(n)}function U(e){let[,,,,n]=e.split("_"),t=Buffer.from(n!=null?n:"","base64").toString().split(".")[1],r=Buffer.from(t!=null?t:"","base64").toString();return JSON.parse(r)}var C={generateClientToken:"blob.generate-client-token",uploadCompleted:"blob.upload-completed"};async function x({token:e,request:n,body:t,onBeforeGenerateToken:r,onUploadCompleted:o}){var i,d,h;if(!t.type)throw new Error("Invalid event type");let a=t.type;switch(a){case"blob.generate-client-token":{let{pathname:u,callbackUrl:g}=t.payload,B=await r(u);return{type:a,clientToken:await w({...B,token:e,pathname:u,onUploadCompleted:{callbackUrl:g,metadata:(i=B.metadata)!=null?i:null}})}}case"blob.upload-completed":{let u="x-vercel-signature",g="credentials"in n?(d=n.headers.get(u))!=null?d:"":(h=n.headers[u])!=null?h:"";if(!g)throw new Error("Invalid callback signature");if(!await k({signature:g,body:JSON.stringify(t)}))throw new Error("Invalid callback signature");return await o(t.payload),{type:a,response:"ok"}}default:throw new Error("Invalid event type")}}async function $(e,n,t){if(!e)throw new l("pathname is required");if(!n)throw new l("body is required");if(!t||t.access!=="public")throw new l('access must be "public"');let o={authorization:`Bearer ${A(t)?await O({handleBlobUploadUrl:t.handleBlobUploadUrl,pathname:e}):s(t)}`};t.contentType&&(o["x-content-type"]=t.contentType);let a=await b(`${y()}/${e}`,{method:"PUT",body:n,headers:o,duplex:"half"});if(a.status!==200)throw a.status===403?new c:new p;let i=await a.json();return f(i)}async function G(e,n){let t=await b(`${y()}/delete`,{method:"POST",headers:{authorization:`Bearer ${s(n)}`,"content-type":"application/json"},body:JSON.stringify({urls:Array.isArray(e)?e:[e]})});if(t.status!==200)throw t.status===403?new c:new p;let r=await t.json();return Array.isArray(e)?r.map(o=>o?f(o):null):r[0]?f(r[0]):null}async function H(e,n){let t=new URL(y());t.searchParams.set("url",e);let r=await b(t,{method:"GET",headers:{authorization:`Bearer ${s(n)}`}});if(r.status===404)return null;if(r.status!==200)throw r.status===403?new c:new p;let o=await r.json();return f(o)}async function M(e){let n=new URL(y());e!=null&&e.limit&&n.searchParams.set("limit",e.limit.toString()),e!=null&&e.prefix&&n.searchParams.set("prefix",e.prefix),e!=null&&e.cursor&&n.searchParams.set("cursor",e.cursor);let t=await b(n,{method:"GET",headers:{authorization:`Bearer ${s(e)}`}});if(t.status!==200)throw t.status===403?new c:new p;let r=await t.json();return{...r,blobs:r.blobs.map(f)}}function y(){return process.env.VERCEL_BLOB_API_URL||process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL||"https://blob.vercel-storage.com"}function f(e){return{...e,uploadedAt:new Date(e.uploadedAt)}}function E(e){try{return!!new URL(e)}catch{return!1}}async function O(e){let{handleBlobUploadUrl:n,pathname:t}=e,r=E(n)?n:`${window.location.origin}${n}`,o=await b(r,{method:"POST",body:JSON.stringify({type:C.generateClientToken,payload:{pathname:t,callbackUrl:r}})});if(!o.ok)throw new l("Failed to  retrieve the client token");try{let{clientToken:a}=await o.json();return a}catch{throw new l("Failed to retrieve the client token")}}function A(e){return!!(!e.token&&e.handleBlobUploadUrl)}export{c as BlobAccessError,l as BlobError,p as BlobUnknownError,G as del,w as generateClientTokenFromReadWriteToken,U as getPayloadFromClientToken,x as handleBlobUpload,H as head,M as list,$ as put,k as verifyCallbackSignature};
